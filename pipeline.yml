---
resource_types:
- name: pivnet
  type: docker-image
  source:
    repository: pivotalcf/pivnet-resource
    tag: latest-final
resources:
- name: template
  type: git
  source:
    uri: https://github.com/pivotal-cf/terraforming-aws.git
    # tag_filter: v0.24.0
    branch: master
- name: terraform-state
  type: s3
  source:
    disable_ssl: false
    access_key_id: ((aws_access_key_id))
    secret_access_key: ((aws_secret_access_key))
    endpoint: ((s3_endpoint))
    bucket: ((s3_output_bucket))
    region_name: ((aws_region))
    versioned_file: terraform.tfstate
- name: pas
  type: pivnet
  source:
    api_token: ((pivnet_api_token))
    product_slug: elastic-runtime
    product_version: 2\.5\.*
- name: stemcells-ubuntu-xenial-250
  type: pivnet
  source:
    api_token: ((pivnet_api_token))
    product_slug: stemcells-ubuntu-xenial
    product_version: 250\.*
- name: pivnet-opsmgr
  type: pivnet
  source:
    api_token: ((pivnet_api_token))
    product_slug: ops-manager
    product_version: 2\.5\.1
- name: credhub-service-broker
  type: pivnet
  source:
    api_token: ((pivnet_api_token))
    product_slug: credhub-service-broker
- name: config
  type: git
  source:
    uri: https://github.com/making/pas-pipeline-aws.git
    branch: platform-automation
- name: platform-automation-tasks-s3
  type: s3
  source:
    access_key_id: ((aws_access_key_id))
    secret_access_key: ((aws_secret_access_key))
    region_name: ap-northeast-1
    bucket: p-automation
    regexp: platform-automation-tasks-(.*).zip
- name: platform-automation-image-s3
  type: s3
  source:
    access_key_id: ((aws_access_key_id))
    secret_access_key: ((aws_secret_access_key))
    region_name: ap-northeast-1
    bucket: p-automation
    regexp: platform-automation-image-(.*).tgz
- name: installation
  type: s3
  source:
    disable_ssl: false
    access_key_id: ((aws_access_key_id))
    secret_access_key: ((aws_secret_access_key))
    endpoint: ((s3_endpoint))
    bucket: ((s3_output_bucket))
    region_name: ((aws_region))
    versioned_file: installation.zip

jobs:
- name: create-initial-terraform-state
  build_logs_to_retain: 5
  plan:
  - task: create-bucket
    params:
      S3_BUCKET_TERRAFORM: ((s3_output_bucket))
      S3_ENDPOINT: ((s3_endpoint))
      AWS_DEFAULT_REGION: ((aws_region))
      AWS_ACCESS_KEY_ID: ((aws_access_key_id))
      AWS_SECRET_ACCESS_KEY: ((aws_secret_access_key))
    config:
      platform: linux
      image_resource:
        type: docker-image
        source:
          repository: mesosphere/aws-cli
      run:
        path: sh
        args: 
        - -c
        - |
          LS=$(aws --endpoint-url ${S3_ENDPOINT} s3 ls | grep ${S3_BUCKET_TERRAFORM})
          if [ "${LS}" = "" ];then
            aws --endpoint-url ${S3_ENDPOINT} s3 mb s3://${S3_BUCKET_TERRAFORM}
            aws --endpoint-url ${S3_ENDPOINT} s3api put-bucket-versioning --bucket ${S3_BUCKET_TERRAFORM} --versioning-configuration Status=Enabled
          else
            echo "${S3_BUCKET_TERRAFORM} already exists."
          fi

          FILES=$(aws --endpoint-url ${S3_ENDPOINT} s3 ls s3://${S3_BUCKET_TERRAFORM}/)
          set +e
          echo $FILES | grep terraform.tfstate
          if [ "$?" -gt "0" ]; then
            echo "{\"version\": 3}" > terraform.tfstate
            aws s3 --endpoint-url ${S3_ENDPOINT} cp terraform.tfstate "s3://${S3_BUCKET_TERRAFORM}/terraform.tfstate"
            set +x
            if [ "$?" -gt "0" ]; then
              echo "Failed to upload empty tfstate file"
              exit 1
            fi
          else
            echo "terraform.tfstate file found, skipping"
            exit 0
          fi

- name: pave-aws
  build_logs_to_retain: 5
  serial_groups: [terraform]
  plan:
  - aggregate:
    - get: template
    - get: terraform-state
    - get: pivnet-opsmgr
      params:
        globs: ["*aws*.yml"]
  - task: find-ami
    params:
      REGION: ((aws_region))
    config:
      platform: linux
      image_resource:
        type: docker-image
        source:
          repository: cfinfrastructure/releng-tools
          tag: latest
      inputs:
      - name: pivnet-opsmgr
      outputs:
      - name: ami
      run:
        path: bash
        args:
        - -c
        - |
          set -eo pipefail 
          ami=$(grep $REGION pivnet-opsmgr/*.yml | cut -d' ' -f2)
          echo $ami > ami/ami
  - task: terraform-apply
    params:
      TF_VAR_region: ((aws_region))
      TF_VAR_access_key: ((aws_access_key_id))
      TF_VAR_secret_key: ((aws_secret_access_key))
      TF_VAR_availability_zones: ((availability_zones))
      TF_VAR_env_name: ((env_name))
      TF_VAR_dns_suffix: ((dns_suffix))
      TF_VAR_rds_instance_count: ((rds_instance_count))
      TF_VAR_rds_instance_class: ((rds_instance_class))
      TF_VAR_ops_manager_instance_type: ((ops_manager_instance_type))
      TF_VAR_ssl_cert: ((ssl_cert))
      TF_VAR_ssl_private_key: ((ssl_private_key))
      TF_VAR_hosted_zone: ((hosted_zone))
    config:
      platform: linux
      image_resource:
        type: docker-image
        source:
          repository: cfinfrastructure/releng-tools
          tag: latest
      inputs:
      - name: template
      - name: terraform-state
      - name: ami
      outputs:
      - name: tfstate-output
      run:
        path: bash
        args: 
        - -c
        - |
          set -eo pipefail 
          export TF_VAR_ops_manager_ami=$(cat ami/ami)

          LF=$(printf '\\\012_')
          LF=${LF%_}
          
          # Fix IAM
          sed -i 's/"elasticloadbalancing:DescribeLoadBalancers"/"elasticloadbalancing:DescribeLoadBalancers","elasticloadbalancing:DeregisterInstancesFromLoadBalancer","elasticloadbalancing:RegisterInstancesWithLoadBalancer"/' template/modules/ops_manager/templates/iam_policy.json

          # Customize
          # use smaller infra for poc
 
          sed -i "s/multi_az                = true/multi_az                = false$LF  storage_type            = \"standard\"/g" template/modules/rds/template.tf
          sed -i '/iops/d' template/modules/rds/template.tf

          cat <<'EOD' > template/modules/ops_manager/spot-instance.tf
          resource "aws_iam_policy" "spot_instance" {
              name = "${var.env_name}_spot_instance"
              policy = <<EOF
          {
          "Version": "2012-10-17",
          "Statement": [
              {
                  "Action": "ec2:RequestSpotInstances",
                  "Effect": "Allow",
                  "Resource": "*"
              },
              {
                  "Action": "ec2:DescribeSpotInstanceRequests",
                  "Effect": "Allow",
                  "Resource": "*"
              },
              {
                  "Action": "ec2:CancelSpotInstanceRequests",
                  "Effect": "Allow",
                  "Resource": "*"
              },
              {
                  "Action": "iam:CreateServiceLinkedRole",
                  "Effect": "Allow",
                  "Resource": "*"
              }
          ]
          }
          EOF
          }

          resource "aws_iam_user_policy_attachment" "spot_instance" {
              user       = "${aws_iam_user.ops_manager.name}"
              policy_arn = "${aws_iam_policy.spot_instance.arn}"
          }
          EOD

          # cat <<'EOD' > template/modules/pas/istio.tf
          # # Istio Load Balancer

          # resource "aws_security_group" "istio_lb" {
          #   name        = "istio_lb_security_group"
          #   description = "Load Balancer Security Group"
          #   vpc_id      = "${var.vpc_id}"

          #   ingress {
          #     cidr_blocks = ["0.0.0.0/0"]
          #     protocol    = "tcp"
          #     from_port   = 80
          #     to_port     = 80
          #   }

          #   ingress {
          #     cidr_blocks = ["0.0.0.0/0"]
          #     protocol    = "tcp"
          #     from_port   = 443
          #     to_port     = 443
          #   }

          #   egress {
          #     cidr_blocks = ["0.0.0.0/0"]
          #     protocol    = "-1"
          #     from_port   = 0
          #     to_port     = 0
          #   }

          #   tags = "${merge(var.tags, map("Name", "${var.env_name}-lb-security-group"))}"
          # }

          # resource "aws_lb" "istio" {
          #   name                             = "${var.env_name}-istio-lb"
          #   load_balancer_type               = "network"
          #   enable_cross_zone_load_balancing = true
          #   internal                         = "${var.internetless}"
          #   subnets                          = ["${var.public_subnet_ids}"]
          # }

          # resource "aws_lb_listener" "istio_80" {
          #   load_balancer_arn = "${aws_lb.istio.arn}"
          #   port              = 80
          #   protocol          = "TCP"

          #   default_action {
          #     type             = "forward"
          #     target_group_arn = "${aws_lb_target_group.istio_80.arn}"
          #   }
          # }

          # resource "aws_lb_listener" "istio_443" {
          #   load_balancer_arn = "${aws_lb.istio.arn}"
          #   port              = 443
          #   protocol          = "TCP"

          #   default_action {
          #     type             = "forward"
          #     target_group_arn = "${aws_lb_target_group.istio_443.arn}"
          #   }
          # }

          # resource "aws_lb_target_group" "istio_80" {
          #   name     = "${var.env_name}-istio-tg-80"
          #   port     = 80
          #   protocol = "TCP"
          #   vpc_id   = "${var.vpc_id}"

          #   health_check {
          #     protocol = "TCP"
          #     port     = 8002
          #   }
          # }

          # resource "aws_lb_target_group" "istio_443" {
          #   name     = "${var.env_name}-istio-tg-443"
          #   port     = 443
          #   protocol = "TCP"
          #   vpc_id   = "${var.vpc_id}"

          #   health_check {
          #     protocol = "TCP"
          #     port     = 8002
          #   }
          # }

          # output "istio_target_groups" {
          #   value = [
          #     "${aws_lb_target_group.istio_80.name}",
          #     "${aws_lb_target_group.istio_443.name}",
          #   ]
          # }

          # resource "aws_route53_record" "wildcard_mesh_dns" {
          #   count   = "${var.use_route53}"
          #   zone_id = "${var.zone_id}"
          #   name    = "*.mesh.apps.${var.env_name}.${var.dns_suffix}"
          #   type    = "A"

          #   alias {
          #     name                   = "${aws_lb.istio.dns_name}"
          #     zone_id                = "${aws_lb.istio.zone_id}"
          #     evaluate_target_health = true
          #   }
          # }
          # EOD

          # cat <<'EOF' >> template/terraforming-pas/outputs.tf

          # output "istio_target_groups" {
          #   value = "${module.pas.istio_target_groups}"
          # }
          # EOF

          # Remove SSH/TCP LB
          sed -i 's|resource "aws_security_group" "ssh_lb"|/* resource "aws_security_group" "ssh_lb"|' template/modules/pas/lbs.tf
          echo '*/' >> template/modules/pas/lbs.tf
          sed -i 's|resource "aws_route53_record" "ssh" {|/* resource "aws_route53_record" "ssh" {|' template/modules/pas/dns.tf
          echo '*/' >> template/modules/pas/dns.tf
          sed -i 's/${aws_lb_target_group.tcp.*.name}//g' template/modules/pas/outputs.tf
          sed -i 's/${aws_lb_target_group.ssh.name}//g' template/modules/pas/outputs.tf

          cd template
          echo "======== Diff =========="
          git diff | cat
          echo "========================"
          cd -

          terraform init \
                    template/terraforming-pas
          terraform plan \
                    -out terraform.tfplan \
                    -state terraform-state/terraform.tfstate \
                    template/terraforming-pas
          terraform apply \
                    -state-out tfstate-output/terraform.tfstate \
                    terraform.tfplan
    ensure:
      put: terraform-state
      params:
        file: tfstate-output/terraform.tfstate

- name: configure-authentication
  build_logs_to_retain: 5
  serial_groups: [terraform]
  plan:
  - aggregate:
    - get: terraform-state
      passed:
      - pave-aws
      trigger: true
    - get: config
    - get: platform-automation-tasks-s3
      params:
        unpack: true
    - get: platform-automation-image-s3
      params:
        unpack: true
  - task: create-env
    params:
      OM_USERNAME: ((ops_mgr_usr))
      OM_PASSWORD: ((ops_mgr_pwd))
      OM_DECRYPTION_PASSPHRASE: ((om_decryption_pwd))
      OM_SKIP_SSL_VALIDATION: true
    file: config/config/director/create-env.yml
  - task: create-config
    params:
      OM_USERNAME: ((ops_mgr_usr))
      OM_PASSWORD: ((ops_mgr_pwd))
      OM_DECRYPTION_PASSPHRASE: ((om_decryption_pwd))
    config:
      platform: linux
      image_resource:
        type: docker-image
        source:
          repository: cfinfrastructure/releng-tools
          tag: latest
      outputs:
      - name: created-config
      run:
        path: bash
        args: 
        - -c
        - |
          # http://docs.pivotal.io/platform-automation/v2.1/configuration-management/configure-auth.html
          cat <<EOF > created-config/auth.yml
          username: ${OM_USERNAME}
          password: ${OM_PASSWORD}
          decryption-passphrase: ${OM_DECRYPTION_PASSPHRASE}
          EOF
  - task: configure-authentication
    image: platform-automation-image-s3
    input_mapping:
      config: created-config
    file: platform-automation-tasks-s3/tasks/configure-authentication.yml
  - task: configure-opsman
    params:
      OM_CERT_PEM: ((ssl_cert))
      OM_PRIVATE_PEM: ((ssl_private_key))
      ENV_FILE: env.yml
    config:
      platform: linux
      image_resource:
        type: docker-image
        source:
          repository: cfinfrastructure/releng-tools
          tag: latest
      inputs:
      - name: terraform-state
      - name: env
      run:
        path: bash
        args: 
        - -c
        - |
          set -euo pipefail        
          # Configure TLS
          if [ "${OM_CERT_PEM}" != "" ];then
            cat <<EOF >> cert.pem
          ${OM_CERT_PEM}
          EOF
            cat <<EOF >> private.pem
          ${OM_PRIVATE_PEM}
          EOF
            om --env env/"${ENV_FILE}" \
              update-ssl-certificate \
              --certificate-pem="$(cat cert.pem)" \
              --private-key-pem="$(cat private.pem)"
          fi

- name: configure-vm-types
  build_logs_to_retain: 5
  plan:
  - aggregate:
    - get: terraform-state
      passed:
      - configure-authentication
      trigger: true
    - get: config
  - task: create-env
    params:
      OM_USERNAME: ((ops_mgr_usr))
      OM_PASSWORD: ((ops_mgr_pwd))
      OM_DECRYPTION_PASSPHRASE: ((om_decryption_pwd))
      OM_SKIP_SSL_VALIDATION: true
    file: config/config/director/create-env.yml
  - task: configure-vm-types
    params:
      ENV_FILE: env.yml
    config:
      platform: linux
      image_resource:
        type: docker-image
        source:
          repository: cfinfrastructure/releng-tools
          tag: latest
      inputs:
      - name: env
      - name: config
      run:
        path: bash
        args: 
        - -c
        - |
          set -euo pipefail
          om --env env/"${ENV_FILE}" \
             curl -s -p /api/v0/vm_types | yq -y . | bosh int - > vm-types-old.yml
          bosh int vm-types-old.yml -o config/config/director/ops-vm-types.yml > vm-types-new.yml
          echo "** Diff **"
          diff vm-types-old.yml vm-types-new.yml | cat || true
          om --env env/"${ENV_FILE}" \
             curl -s -p /api/v0/vm_types -x PUT \
             -d "$(cat vm-types-new.yml | yq .)"

- name: prepare-rds
  build_logs_to_retain: 5
  serial_groups: [terraform]
  plan:
  - aggregate:
    - get: terraform-state
      passed:
      - configure-authentication
      trigger: true
  - task: prepare-rds
    config:
      platform: linux
      image_resource:
        type: docker-image
        source:
          repository: cfinfrastructure/releng-tools
          tag: latest
      inputs:
      - name: terraform-state
      run:
        path: bash
        args: 
        - -c
        - |
          set -euo pipefail
          OPSMAN_DOMAIN_OR_IP_ADDRESS=$(terraform output --state=${TERRAFORM_STATE:-terraform-state}/terraform.tfstate ops_manager_dns)
          OPS_MANAGER_SSH_PRIVATE_KEY=$(terraform output --state=${TERRAFORM_STATE:-terraform-state}/terraform.tfstate ops_manager_ssh_private_key)
          cat <<EOF > opsman.pem
          ${OPS_MANAGER_SSH_PRIVATE_KEY}
          EOF
          chmod 600 opsman.pem
          db_host=$(terraform output --state=${TERRAFORM_STATE:-terraform-state}/terraform.tfstate rds_address)
          db_username=$(terraform output --state=${TERRAFORM_STATE:-terraform-state}/terraform.tfstate rds_username)
          db_password=$(terraform output --state=${TERRAFORM_STATE:-terraform-state}/terraform.tfstate rds_password)
          cat > databases.sql <<EOF
          CREATE DATABASE IF NOT EXISTS console;
          CREATE DATABASE IF NOT EXISTS uaa;
          CREATE DATABASE IF NOT EXISTS ccdb;
          CREATE DATABASE IF NOT EXISTS notifications;
          CREATE DATABASE IF NOT EXISTS autoscale;
          CREATE DATABASE IF NOT EXISTS app_usage_service;
          CREATE DATABASE IF NOT EXISTS routing;
          CREATE DATABASE IF NOT EXISTS diego;
          CREATE DATABASE IF NOT EXISTS account;
          CREATE DATABASE IF NOT EXISTS nfsvolume;
          CREATE DATABASE IF NOT EXISTS networkpolicyserver;
          CREATE DATABASE IF NOT EXISTS silk;
          CREATE DATABASE IF NOT EXISTS locket;
          CREATE DATABASE IF NOT EXISTS credhub;
          EOF
          scp -i opsman.pem -o StrictHostKeyChecking=no databases.sql "ubuntu@${OPSMAN_DOMAIN_OR_IP_ADDRESS}:/tmp/."
          ssh -i opsman.pem -o StrictHostKeyChecking=no "ubuntu@${OPSMAN_DOMAIN_OR_IP_ADDRESS}" "mysql -h $db_host -u $db_username -p$db_password < /tmp/databases.sql"

- name: configure-director
  build_logs_to_retain: 5
  serial_groups: [terraform]
  plan:
  - aggregate:
    - get: terraform-state
      passed:
      - configure-vm-types
      trigger: true
    - get: config
    - get: platform-automation-tasks-s3
      params:
        unpack: true
    - get: platform-automation-image-s3
      params:
        unpack: true
  - task: create-env
    params:
      OM_USERNAME: ((ops_mgr_usr))
      OM_PASSWORD: ((ops_mgr_pwd))
      OM_DECRYPTION_PASSPHRASE: ((om_decryption_pwd))
      OM_SKIP_SSL_VALIDATION: true
    file: config/config/director/create-env.yml
  - task: create-vars
    params:
      TF_DIR: terraform-state
    config:
      platform: linux
      image_resource:
        type: docker-image
        source:
          repository: cfinfrastructure/releng-tools
          tag: latest
      inputs:
      - name: config
      - name: terraform-state
      outputs:
      - name: vars
      run:
        path: bash
        args: 
        - -c
        - |
          set -e
          ./config/config/director/create-vars.sh > vars/vars.yml
  - task: configure-director
    params:
      DIRECTOR_CONFIG_FILE: config/director/config.yml
      VARS_FILES: vars/vars.yml
    image: platform-automation-image-s3
    file: platform-automation-tasks-s3/tasks/configure-director.yml

- name: upload-pas
  build_logs_to_retain: 5
  serial_groups: [terraform]
  plan:
  - aggregate:
    - get: terraform-state
      passed:
      - configure-director
      trigger: true
    - get: product
      resource: pas
      trigger: true
      params:
        globs:
        - "srt*.pivotal" # Small Footprint
    - get: stemcell
      resource: stemcells-ubuntu-xenial-250
      trigger: true
      params:
        globs:
        - "light-bosh-stemcell-*-aws-xen-hvm-ubuntu-xenial-go_agent.tgz"
    - get: config
    - get: platform-automation-tasks-s3
      params:
        unpack: true
    - get: platform-automation-image-s3
      params:
        unpack: true
  - task: create-env
    params:
      OM_USERNAME: ((ops_mgr_usr))
      OM_PASSWORD: ((ops_mgr_pwd))
      OM_DECRYPTION_PASSPHRASE: ((om_decryption_pwd))
      OM_SKIP_SSL_VALIDATION: true
    file: config/config/director/create-env.yml
  - task: upload-and-stage-product
    image: platform-automation-image-s3
    file: platform-automation-tasks-s3/tasks/upload-and-stage-product.yml
  - task: upload-stemcell
    image: platform-automation-image-s3
    file: platform-automation-tasks-s3/tasks/upload-stemcell.yml

- name: configure-pas
  build_logs_to_retain: 5
  serial_groups: [terraform]
  plan:
  - aggregate:
    - get: terraform-state
      passed:
      - upload-pas
      trigger: true
    - get: config
    - get: pas
      passed:
      - upload-pas
      params:
        globs: 
        - "cf-cli-*"
      trigger: true
    - get: platform-automation-tasks-s3
      params:
        unpack: true
    - get: platform-automation-image-s3
      params:
        unpack: true
  - task: create-env
    params:
      OM_USERNAME: ((ops_mgr_usr))
      OM_PASSWORD: ((ops_mgr_pwd))
      OM_DECRYPTION_PASSPHRASE: ((om_decryption_pwd))
      OM_SKIP_SSL_VALIDATION: true
    file: config/config/director/create-env.yml
  - task: create-vars
    params:
      CERT_PEM: ((ssl_cert))
      KEY_PEM: ((ssl_private_key))
      OM_USERNAME: ((ops_mgr_usr))
      OM_PASSWORD: ((ops_mgr_pwd))
      OM_SKIP_SSL_VALIDATION: true
      SMTP_FROM: ((smtp_from))
      SMTP_ADDRESS: ((smtp_address)) 
      SMTP_PORT: ((smtp_port))
      SMTP_USERNAME: ((smtp_username))
      SMTP_PASSWORD: ((smtp_password))
      SMTP_ENABLE_STARTTLS: ((smtp_enable_starttls))
      ENV_FILE: env.yml
      TF_DIR: terraform-state
    config:
      platform: linux
      image_resource:
        type: docker-image
        source:
          repository: cfinfrastructure/releng-tools
          tag: latest
      inputs:
      - name: config
      - name: env
      - name: terraform-state
      outputs:
      - name: vars
      run:
        path: bash
        args: 
        - -c
        - |
          set -e
          ./config/config/pas/create-vars.sh > vars/vars.yml
  - task: configure-product
    params:
      CONFIG_FILE: config/pas/config.yml
      VARS_FILES: vars/vars.yml
    image: platform-automation-image-s3
    file: platform-automation-tasks-s3/tasks/configure-product.yml

- name: upload-credhub-service-broker
  build_logs_to_retain: 5
  serial_groups: [terraform]
  plan:
  - aggregate:
    - get: terraform-state
      passed:
      - configure-pas
      trigger: true
    - get: product
      resource: credhub-service-broker
      params:
        globs:
        - "*.pivotal"
    - get: stemcell
      resource: stemcells-ubuntu-xenial-250
      trigger: true
      params:
        globs:
        - "light-bosh-stemcell-*-aws-xen-hvm-ubuntu-xenial-go_agent.tgz"
    - get: config
    - get: platform-automation-tasks-s3
      params:
        unpack: true
    - get: platform-automation-image-s3
      params:
        unpack: true
  - task: create-env
    params:
      OM_USERNAME: ((ops_mgr_usr))
      OM_PASSWORD: ((ops_mgr_pwd))
      OM_DECRYPTION_PASSPHRASE: ((om_decryption_pwd))
      OM_SKIP_SSL_VALIDATION: true
    file: config/config/director/create-env.yml
  - task: upload-and-stage-product
    image: platform-automation-image-s3
    file: platform-automation-tasks-s3/tasks/upload-and-stage-product.yml
  - task: upload-stemcell
    image: platform-automation-image-s3
    file: platform-automation-tasks-s3/tasks/upload-stemcell.yml

- name: configure-credbhub-service-broker
  build_logs_to_retain: 5
  serial: true
  plan:
  - aggregate:
    - get: terraform-state
      passed:
      - upload-credhub-service-broker
      trigger: true
    - get: config
    - get: product
      resource: credhub-service-broker
      params:
        globs:
        - "*.pivotal"
      passed:
      - upload-credhub-service-broker
      trigger: true
    - get: platform-automation-tasks-s3
      params:
        unpack: true
    - get: platform-automation-image-s3
      params:
        unpack: true
  - task: create-env
    params:
      OM_USERNAME: ((ops_mgr_usr))
      OM_PASSWORD: ((ops_mgr_pwd))
      OM_DECRYPTION_PASSPHRASE: ((om_decryption_pwd))
      OM_SKIP_SSL_VALIDATION: true
    file: config/config/director/create-env.yml
  - task: create-vars
    params:
      TF_DIR: terraform-state
    config:
      platform: linux
      image_resource:
        type: docker-image
        source:
          repository: cfinfrastructure/releng-tools
          tag: latest
      inputs:
      - name: config
      - name: env
      - name: terraform-state
      outputs:
      - name: vars
      run:
        path: bash
        args: 
        - -c
        - |
          set -e
          ./config/config/credhub-service-broker/create-vars.sh > vars/vars.yml
  - task: configure-product
    params:
      CONFIG_FILE: config/credhub-service-broker/config.yml
      VARS_FILES: vars/vars.yml
    image: platform-automation-image-s3
    file: platform-automation-tasks-s3/tasks/configure-product.yml

- name: apply-changes
  build_logs_to_retain: 5
  serial_groups: [terraform]
  plan:
  - aggregate:
    - get: terraform-state
      passed:
      - configure-credbhub-service-broker
      trigger: true
    - get: config
    - get: platform-automation-tasks-s3
      params:
        unpack: true
    - get: platform-automation-image-s3
      params:
        unpack: true
  - task: create-env
    params:
      OM_USERNAME: ((ops_mgr_usr))
      OM_PASSWORD: ((ops_mgr_pwd))
      OM_DECRYPTION_PASSPHRASE: ((om_decryption_pwd))
      OM_SKIP_SSL_VALIDATION: true
    file: config/config/director/create-env.yml
  - task: apply-changes
    image: platform-automation-image-s3
    file: platform-automation-tasks-s3/tasks/apply-changes.yml

- name: wipe-env
  build_logs_to_retain: 5
  serial_groups: [terraform]
  ensure:
    put: terraform-state
    params:
      file: tfstate-output/terraform.tfstate
  plan:
  - aggregate:
    - get: template
      passed:
      - pave-aws
    - get: terraform-state
      passed:
      - pave-aws
    - get: pivnet-opsmgr
      passed:
      - pave-aws
      params:
        globs: ["*aws*.yml"]
    - get: config
    - get: platform-automation-tasks-s3
      params:
        unpack: true
    - get: platform-automation-image-s3
      params:
        unpack: true
  - aggregate:
    - task: create-env
      params:
        OM_USERNAME: ((ops_mgr_usr))
        OM_PASSWORD: ((ops_mgr_pwd))
        OM_DECRYPTION_PASSPHRASE: ((om_decryption_pwd))
        OM_SKIP_SSL_VALIDATION: true
      file: config/config/director/create-env.yml
    - task: find-ami
      params:
        REGION: ((aws_region))
      config:
        platform: linux
        image_resource:
          type: docker-image
          source:
            repository: cfinfrastructure/releng-tools
            tag: latest
        inputs:
        - name: pivnet-opsmgr
        outputs:
        - name: ami
        run:
          path: bash
          args:
          - -c
          - |
            set -eo pipefail 
            ami=$(grep $REGION pivnet-opsmgr/*.yml | cut -d' ' -f2)
            echo $ami > ami/ami
  - task: delete-installation
    image: platform-automation-image-s3
    file: platform-automation-tasks-s3/tasks/delete-installation.yml
  - task: terraform-destory
    params:
      TF_VAR_region: ((aws_region))
      TF_VAR_access_key: ((aws_access_key_id))
      TF_VAR_secret_key: ((aws_secret_access_key))
      TF_VAR_availability_zones: ((availability_zones))
      TF_VAR_env_name: ((env_name))
      TF_VAR_dns_suffix: ((dns_suffix))
      TF_VAR_rds_instance_count: ((rds_instance_count))
      TF_VAR_rds_instance_class: ((rds_instance_class))
      TF_VAR_ops_manager_instance_type: ((ops_manager_instance_type))
      TF_VAR_ssl_cert: ((ssl_cert))
      TF_VAR_ssl_private_key: ((ssl_private_key))
      TF_VAR_hosted_zone: ((hosted_zone))
    config:
      platform: linux
      image_resource:
        type: docker-image
        source:
          repository: cfinfrastructure/releng-tools
          tag: latest
      inputs:
      - name: template
      - name: terraform-state
      - name: ami
      outputs:
      - name: tfstate-output
      run:
        path: sh
        args: 
        - -c
        - |
          set -e
          export TF_VAR_ops_manager_ami=$(cat ami/ami)

          # Remove SSH/TCP LB
          sed -i 's|resource "aws_security_group" "ssh_lb"|/* resource "aws_security_group" "ssh_lb"|' template/modules/pas/lbs.tf
          echo '*/' >> template/modules/pas/lbs.tf
          sed -i 's|resource "aws_route53_record" "ssh" {|/* resource "aws_route53_record" "ssh" {|' template/modules/pas/dns.tf
          echo '*/' >> template/modules/pas/dns.tf
          sed -i 's/${aws_lb_target_group.tcp.*.name}//g' template/modules/pas/outputs.tf
          sed -i 's/${aws_lb_target_group.ssh.name}//g' template/modules/pas/outputs.tf

          terraform init \
                    template/terraforming-pas
          terraform destroy \
                    -force \
                    -state terraform-state/terraform.tfstate \
                    -state-out tfstate-output/terraform.tfstate \
                    template/terraforming-pas

- name: show-ssh-opsman-script
  build_logs_to_retain: 5
  plan:
  - aggregate:
    - get: terraform-state
      passed:
      - configure-director
  - task: show-ssh-opsman-script
    params:
      TF_DIR: terraform-state
    config:
      platform: linux
      image_resource:
        type: docker-image
        source:
          repository: cfinfrastructure/releng-tools
          tag: latest
      inputs:
      - name: terraform-state
      run:
        path: bash
        args: 
        - -c
        - |
          set -eo pipefail
          cp terraform-state/terraform.tfstate ./
          export OM_TARGET=$(terraform output --state=${TF_DIR}/terraform.tfstate ops_manager_dns)
          OPS_MANAGER_SSH_PRIVATE_KEY=$(terraform output --state=${TF_DIR}/terraform.tfstate ops_manager_ssh_private_key)
          
          cat <<EOF
          #!/bin/bash
          cat << KEY > opsman.pem
          ${OPS_MANAGER_SSH_PRIVATE_KEY}
          KEY
          chmod 600 opsman.pem
          ssh -i opsman.pem -o "StrictHostKeyChecking=no" -l ubuntu ${OM_TARGET}
          EOF

- name: configure-bosh-cli
  build_logs_to_retain: 5
  plan:
  - aggregate:
    - get: terraform-state
      passed:
      - configure-pas
    - get: config
  - task: create-env
    params:
      OM_USERNAME: ((ops_mgr_usr))
      OM_PASSWORD: ((ops_mgr_pwd))
      OM_DECRYPTION_PASSPHRASE: ((om_decryption_pwd))
      OM_SKIP_SSL_VALIDATION: true
    file: config/config/director/create-env.yml
  - task: configure-bosh-cli
    params:
      ENV_FILE: env.yml
      TF_DIR: terraform-state
    config:
      platform: linux
      image_resource:
        type: docker-image
        source:
          repository: cfinfrastructure/releng-tools
          tag: latest
      inputs:
      - name: terraform-state
      - name: env
      run:
        path: bash
        args: 
        - -c
        - |
          set -eo pipefail
          export OM_TARGET=$(terraform output --state=${TF_DIR}/terraform.tfstate ops_manager_dns)
          OPS_MANAGER_SSH_PRIVATE_KEY=$(terraform output --state=${TF_DIR}/terraform.tfstate ops_manager_ssh_private_key)
          
          cat <<EOF > opsman.pem
          ${OPS_MANAGER_SSH_PRIVATE_KEY}
          EOF
          chmod 400 opsman.pem
          BOSH_CLI=$(om --env env/"${ENV_FILE}" curl -s -p "/api/v0/deployed/director/credentials/bosh_commandline_credentials" | jq -r '.credential')
          ssh -q -i opsman.pem \
            -o "StrictHostKeyChecking=no" \
            ubuntu@${OM_TARGET} "echo $BOSH_CLI | sed 's/ /\n/g' | sed 's/^/export /g' | sed '/bosh/d' | sudo tee /etc/profile.d/bosh.sh" > /dev/null

################
- name: export-installation
  build_logs_to_retain: 5
  plan:
  - aggregate:
    - get: terraform-state
    - get: config
    - get: platform-automation-tasks-s3
      params:
        unpack: true
    - get: platform-automation-image-s3
      params:
        unpack: true
  - task: create-env
    params:
      OM_USERNAME: ((ops_mgr_usr))
      OM_PASSWORD: ((ops_mgr_pwd))
      OM_DECRYPTION_PASSPHRASE: ((om_decryption_pwd))
      OM_SKIP_SSL_VALIDATION: true
    file: config/config/director/create-env.yml
  - task: export-installation
    params:
      INSTALLATION_FILE: installation.zip
    image: platform-automation-image-s3
    file: platform-automation-tasks-s3/tasks/export-installation.yml
  - put: installation
    params:
      file: installation/installation.zip


- name: upgrade-opsman
  build_logs_to_retain: 5
  plan:
  - aggregate:
    - get: installation
      passed:
      - export-installation
    - get: terraform-state
    - get: pivnet-opsmgr
      params:
        globs: ["*aws*.yml"]
    - get: config
    - get: platform-automation-tasks-s3
      params:
        unpack: true
    - get: platform-automation-image-s3
      params:
        unpack: true
  - aggregate:
    - task: create-env
      params:
        OM_USERNAME: ((ops_mgr_usr))
        OM_PASSWORD: ((ops_mgr_pwd))
        OM_DECRYPTION_PASSPHRASE: ((om_decryption_pwd))
        OM_SKIP_SSL_VALIDATION: true
      file: config/config/director/create-env.yml
    - task: create-state
      params:
        TF_DIR: terraform-state
        IAAS: aws
      config:
        platform: linux
        image_resource:
          type: docker-image
          source:
            repository: cfinfrastructure/releng-tools
            tag: latest
        inputs:
        - name: terraform-state
        outputs:
        - name: state
        run:
          path: bash
          args: 
          - -c
          - |
            set -e
            export VM_ID=$(cat $TF_DIR/terraform.tfstate | jq -r '.modules[] | select(.resources["aws_instance.ops_manager"] != null).resources["aws_instance.ops_manager"].primary.attributes.id')
            cat <<EOF > state/state.yml
            iaas: ${IAAS}
            vm_id: ${VM_ID}
            EOF
    - task: create-image
      config:
        platform: linux
        image_resource:
          type: docker-image
          source:
            repository: cfinfrastructure/releng-tools
            tag: latest
        inputs:
        - name: pivnet-opsmgr
        outputs:
        - name: image
        run:
          path: bash
          args: 
          - -c
          - |
            set -e
            mv pivnet-opsmgr/*.yml image/opsman.yml
    - task: create-vars
      params:
        TF_DIR: terraform-state
      config:
        platform: linux
        image_resource:
          type: docker-image
          source:
            repository: cfinfrastructure/releng-tools
            tag: latest
        inputs:
        - name: config
        - name: terraform-state
        outputs:
        - name: vars
        run:
          path: bash
          args: 
          - -c
          - |
            set -e
            ./config/config/director/create-vars.sh > vars/vars.yml
    - task: create-config
      params:
        TF_DIR: terraform-state
      config:
        platform: linux
        image_resource:
          type: docker-image
          source:
            repository: cfinfrastructure/releng-tools
            tag: latest
        inputs:
        - name: config
        - name: terraform-state
        outputs:
        - name: created-config
        run:
          path: bash
          args: 
          - -c
          - |
            set -e
            export ACCESS_KEY_ID=$(terraform output --state=${TF_DIR}/terraform.tfstate ops_manager_iam_user_access_key)
            export SECRET_ACCESS_KEY=$(terraform output --state=${TF_DIR}/terraform.tfstate ops_manager_iam_user_secret_key)
            export SECURITY_GROUP=$(terraform output --state=${TF_DIR}/terraform.tfstate ops_manager_security_group_id)
            export REGION=$(terraform output --state=${TF_DIR}/terraform.tfstate region)
            export KEY_PAIR_NAME=$(terraform output --state=${TF_DIR}/terraform.tfstate ops_manager_ssh_public_key_name)
            export PRIVATE_IP=$(terraform output --state=${TF_DIR}/terraform.tfstate ops_manager_private_ip)
            export PUBLIC_IP=$(terraform output --state=${TF_DIR}/terraform.tfstate ops_manager_public_ip)
            export SUBNET_ID=$(terraform output --state=${TF_DIR}/terraform.tfstate -json public_subnet_ids | jq -r '.value[0]')
            export INSTANCE_PROFILE_NAME=$(terraform output --state=${TF_DIR}/terraform.tfstate ops_manager_iam_instance_profile_name)
            export VM_NAME=$(cat $TF_DIR/terraform.tfstate | jq -r '.modules[] | select(.resources["aws_instance.ops_manager"] != null).resources["aws_instance.ops_manager"].primary.attributes["tags.Name"]')
            export INSTANCE_TYPE=$(cat $TF_DIR/terraform.tfstate | jq -r '.modules[] | select(.resources["aws_instance.ops_manager"] != null).resources["aws_instance.ops_manager"].primary.attributes.instance_type')
            export BOOT_DISK_SIZE=$(cat $TF_DIR/terraform.tfstate | jq -r '.modules[] | select(.resources["aws_instance.ops_manager"] != null).resources["aws_instance.ops_manager"].primary.attributes["root_block_device.0.volume_size"]')
            cat <<EOF > created-config/opsman.yml
            opsman-configuration:
              aws:
                access_key_id: ${ACCESS_KEY_ID}
                secret_access_key: ${SECRET_ACCESS_KEY}
                region: ${REGION}
                vm_name: ${VM_NAME}
                boot_disk_size: ${BOOT_DISK_SIZE}
                vpc_subnet_id: ${SUBNET_ID}
                security_group_id: ${SECURITY_GROUP}
                key_pair_name: ${KEY_PAIR_NAME}
                iam_instance_profile_name: ${INSTANCE_PROFILE_NAME}
                instance_type: ${INSTANCE_TYPE}
                public_ip: ${PUBLIC_IP}
                private_ip: ${PRIVATE_IP}
            EOF
            cat created-config/opsman.yml
  - task: upgrade-opsman
    params:
      DIRECTOR_CONFIG_FILE: config/director/config.yml
      VARS_FILES: vars/vars.yml
    image: platform-automation-image-s3
    input_mapping:
      config: created-config
    file: platform-automation-tasks-s3/tasks/upgrade-opsman.yml